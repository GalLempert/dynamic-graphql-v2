package sigma.persistence.dialect;

import java.util.List;

/**
 * Oracle dialect implementation using JSON type for document storage.
 * Compatible with Oracle 21c and later which has native JSON support.
 * Uses JSON_VALUE, JSON_QUERY, and JSON_EXISTS functions.
 */
public class OracleDialect implements DatabaseDialect {

    @Override
    public DatabaseType getType() {
        return DatabaseType.ORACLE;
    }

    @Override
    public String getCreateTableSql() {
        return """
            CREATE TABLE dynamic_documents (
                id NUMBER(19) GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
                table_name VARCHAR2(255) NOT NULL,
                data CLOB DEFAULT '{}' CHECK (data IS JSON),
                version NUMBER(19) DEFAULT 0,
                is_deleted NUMBER(1) DEFAULT 0,
                latest_request_id VARCHAR2(255),
                created_by VARCHAR2(255),
                last_modified_by VARCHAR2(255),
                created_at TIMESTAMP WITH TIME ZONE,
                last_modified_at TIMESTAMP WITH TIME ZONE,
                sequence_number NUMBER(19) DEFAULT 0 NOT NULL
            )
            """;
    }

    @Override
    public List<String> getCreateIndexesSql() {
        return List.of(
            "CREATE INDEX idx_dyn_docs_table_name ON dynamic_documents(table_name)",
            "CREATE INDEX idx_dyn_docs_not_deleted ON dynamic_documents(table_name, is_deleted)",
            "CREATE INDEX idx_dyn_docs_last_modified ON dynamic_documents(table_name, last_modified_at)",
            "CREATE INDEX idx_dyn_docs_sequence ON dynamic_documents(table_name, sequence_number)"
            // Note: Oracle uses JSON search indexes differently - can be added if needed
        );
    }

    @Override
    public List<String> getSequenceSupportSql() {
        return List.of(
            "CREATE SEQUENCE dynamic_documents_seq_num START WITH 1 INCREMENT BY 1",
            """
                CREATE OR REPLACE TRIGGER trg_update_sequence_number
                BEFORE INSERT OR UPDATE ON dynamic_documents
                FOR EACH ROW
                BEGIN
                    :NEW.sequence_number := dynamic_documents_seq_num.NEXTVAL;
                END;
                """
        );
    }

    @Override
    public String jsonExtractText(String column, String fieldPath) {
        return String.format("JSON_VALUE(%s, '$.%s')", column, escapeFieldPath(fieldPath));
    }

    @Override
    public String jsonExtractJson(String column, String fieldPath) {
        return String.format("JSON_QUERY(%s, '$.%s')", column, escapeFieldPath(fieldPath));
    }

    @Override
    public String jsonNumericValue(String column, String fieldPath) {
        return String.format("TO_NUMBER(JSON_VALUE(%s, '$.%s'))", column, escapeFieldPath(fieldPath));
    }

    @Override
    public String jsonEquals(String column, String fieldPath, String paramName) {
        return String.format("JSON_VALUE(%s, '$.%s') = :%s", column, escapeFieldPath(fieldPath), paramName);
    }

    @Override
    public String jsonNotEquals(String column, String fieldPath, String paramName) {
        String escaped = escapeFieldPath(fieldPath);
        return String.format("(JSON_VALUE(%s, '$.%s') IS NULL OR JSON_VALUE(%s, '$.%s') != :%s)",
            column, escaped, column, escaped, paramName);
    }

    @Override
    public String jsonGreaterThan(String column, String fieldPath, String paramName) {
        return String.format("TO_NUMBER(JSON_VALUE(%s, '$.%s')) > :%s",
            column, escapeFieldPath(fieldPath), paramName);
    }

    @Override
    public String jsonGreaterThanOrEqual(String column, String fieldPath, String paramName) {
        return String.format("TO_NUMBER(JSON_VALUE(%s, '$.%s')) >= :%s",
            column, escapeFieldPath(fieldPath), paramName);
    }

    @Override
    public String jsonLessThan(String column, String fieldPath, String paramName) {
        return String.format("TO_NUMBER(JSON_VALUE(%s, '$.%s')) < :%s",
            column, escapeFieldPath(fieldPath), paramName);
    }

    @Override
    public String jsonLessThanOrEqual(String column, String fieldPath, String paramName) {
        return String.format("TO_NUMBER(JSON_VALUE(%s, '$.%s')) <= :%s",
            column, escapeFieldPath(fieldPath), paramName);
    }

    @Override
    public String jsonIn(String column, String fieldPath, String paramName) {
        return String.format("JSON_VALUE(%s, '$.%s') IN (:%s)", column, escapeFieldPath(fieldPath), paramName);
    }

    @Override
    public String jsonNotIn(String column, String fieldPath, String paramName) {
        String escaped = escapeFieldPath(fieldPath);
        return String.format("(JSON_VALUE(%s, '$.%s') IS NULL OR JSON_VALUE(%s, '$.%s') NOT IN (:%s))",
            column, escaped, column, escaped, paramName);
    }

    @Override
    public String jsonLike(String column, String fieldPath, String paramName) {
        return String.format("JSON_VALUE(%s, '$.%s') LIKE :%s", column, escapeFieldPath(fieldPath), paramName);
    }

    @Override
    public String jsonExists(String column, String fieldPath, boolean shouldExist) {
        if (shouldExist) {
            return String.format("JSON_EXISTS(%s, '$.%s')", column, escapeFieldPath(fieldPath));
        } else {
            return String.format("NOT JSON_EXISTS(%s, '$.%s')", column, escapeFieldPath(fieldPath));
        }
    }

    @Override
    public String jsonTypeCheck(String column, String fieldPath, String jsonType) {
        // Oracle uses JSON_VALUE with type checking differently
        // We check by attempting to get value with specific type
        return switch (jsonType) {
            case "string" -> String.format(
                "JSON_VALUE(%s, '$.%s' RETURNING VARCHAR2(4000)) IS NOT NULL",
                column, escapeFieldPath(fieldPath));
            case "number" -> String.format(
                "JSON_VALUE(%s, '$.%s' RETURNING NUMBER) IS NOT NULL",
                column, escapeFieldPath(fieldPath));
            case "boolean" -> String.format(
                "(JSON_VALUE(%s, '$.%s') IN ('true', 'false'))",
                column, escapeFieldPath(fieldPath));
            case "array" -> String.format(
                "JSON_QUERY(%s, '$.%s') IS NOT NULL AND JSON_QUERY(%s, '$.%s[0]') IS NOT NULL",
                column, escapeFieldPath(fieldPath), column, escapeFieldPath(fieldPath));
            case "object" -> String.format(
                "JSON_QUERY(%s, '$.%s') IS NOT NULL AND JSON_QUERY(%s, '$.%s[0]') IS NULL",
                column, escapeFieldPath(fieldPath), column, escapeFieldPath(fieldPath));
            case "null" -> String.format(
                "JSON_VALUE(%s, '$.%s') IS NULL AND JSON_EXISTS(%s, '$.%s')",
                column, escapeFieldPath(fieldPath), column, escapeFieldPath(fieldPath));
            default -> "1=1";
        };
    }

    @Override
    public String jsonArrayExpand(String column, String fieldPath, String alias) {
        // Oracle uses JSON_TABLE for array expansion
        return String.format(
            "JSON_TABLE(%s, '$.%s[*]' COLUMNS (value CLOB FORMAT JSON PATH '$')) %s",
            column, escapeFieldPath(fieldPath), alias);
    }

    @Override
    public String jsonCast(String paramName) {
        return ":" + paramName;
    }

    @Override
    public String getInsertSql() {
        return """
            INSERT INTO dynamic_documents (table_name, data, version, is_deleted, latest_request_id,
                created_by, last_modified_by, created_at, last_modified_at)
            VALUES (:tableName, :data, :version, :isDeleted, :latestRequestId,
                :createdBy, :lastModifiedBy, :createdAt, :lastModifiedAt)
            """;
    }

    @Override
    public String getUpdateSql() {
        return """
            UPDATE dynamic_documents
            SET data = :data, version = :version, is_deleted = :isDeleted,
                latest_request_id = :latestRequestId, last_modified_by = :lastModifiedBy,
                last_modified_at = :lastModifiedAt
            WHERE id = :id
            """;
    }

    @Override
    public boolean supportsReturningClause() {
        // Oracle supports RETURNING INTO but it requires OUT parameter binding
        // For simplicity, we use separate query approach
        return false;
    }

    @Override
    public String getLastInsertIdSql() {
        return "SELECT dynamic_documents_id_seq.CURRVAL FROM DUAL";
    }

    @Override
    public String limitClause(int limit) {
        return "FETCH FIRST " + limit + " ROWS ONLY";
    }

    @Override
    public String offsetClause(int offset) {
        return "OFFSET " + offset + " ROWS";
    }

    @Override
    public String escapeFieldPath(String fieldPath) {
        // Oracle JSON path escaping
        return fieldPath.replace("'", "''").replace("\"", "\\\"");
    }

    @Override
    public boolean requiresBooleanConversion() {
        return true;
    }

    @Override
    public Object convertBoolean(boolean value) {
        return value ? 1 : 0;
    }
}
